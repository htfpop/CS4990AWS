{"ast":null,"code":"/*\r\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\r\n * the License. A copy of the License is located at\r\n *\r\n *     http://aws.amazon.com/apache2.0/\r\n *\r\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\r\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\r\n * and limitations under the License.\r\n */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ConsoleLogger as Logger } from './Logger';\nimport { Sha256 as jsSha256 } from '@aws-crypto/sha256-js';\nimport { toHex } from '@aws-sdk/util-hex-encoding';\nimport { parse, format } from 'url';\nimport { DateUtils } from './Util';\nvar logger = new Logger('Signer');\nvar DEFAULT_ALGORITHM = 'AWS4-HMAC-SHA256';\nvar IOT_SERVICE_NAME = 'iotdevicegateway';\n\nvar encrypt = function encrypt(key, src) {\n  var hash = new jsSha256(key);\n  hash.update(src);\n  return hash.digestSync();\n};\n\nvar hash = function hash(src) {\n  var arg = src || '';\n  var hash = new jsSha256();\n  hash.update(arg);\n  return toHex(hash.digestSync());\n};\n/**\r\n * @private\r\n * RFC 3986 compliant version of encodeURIComponent\r\n */\n\n\nvar escape_RFC3986 = function escape_RFC3986(component) {\n  return component.replace(/[!'()*]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n};\n/**\r\n * @private\r\n * Create canonical query string\r\n *\r\n */\n\n\nvar canonical_query = function canonical_query(query) {\n  if (!query || query.length === 0) {\n    return '';\n  }\n\n  return query.split('&').map(function (e) {\n    var key_val = e.split('=');\n\n    if (key_val.length === 1) {\n      return e;\n    } else {\n      var reencoded_val = escape_RFC3986(key_val[1]);\n      return key_val[0] + '=' + reencoded_val;\n    }\n  }).sort(function (a, b) {\n    var key_a = a.split('=')[0];\n    var key_b = b.split('=')[0];\n\n    if (key_a === key_b) {\n      return a < b ? -1 : 1;\n    } else {\n      return key_a < key_b ? -1 : 1;\n    }\n  }).join('&');\n};\n/**\r\n* @private\r\n* Create canonical headers\r\n*\r\n<pre>\r\nCanonicalHeaders =\r\n    CanonicalHeadersEntry0 + CanonicalHeadersEntry1 + ... + CanonicalHeadersEntryN\r\nCanonicalHeadersEntry =\r\n    Lowercase(HeaderName) + ':' + Trimall(HeaderValue) + '\\n'\r\n</pre>\r\n*/\n\n\nvar canonical_headers = function canonical_headers(headers) {\n  if (!headers || Object.keys(headers).length === 0) {\n    return '';\n  }\n\n  return Object.keys(headers).map(function (key) {\n    return {\n      key: key.toLowerCase(),\n      value: headers[key] ? headers[key].trim().replace(/\\s+/g, ' ') : ''\n    };\n  }).sort(function (a, b) {\n    return a.key < b.key ? -1 : 1;\n  }).map(function (item) {\n    return item.key + ':' + item.value;\n  }).join('\\n') + '\\n';\n};\n/**\r\n * List of header keys included in the canonical headers.\r\n * @access private\r\n */\n\n\nvar signed_headers = function signed_headers(headers) {\n  return Object.keys(headers).map(function (key) {\n    return key.toLowerCase();\n  }).sort().join(';');\n};\n/**\r\n* @private\r\n* Create canonical request\r\n* Refer to\r\n* {@link http://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html|Create a Canonical Request}\r\n*\r\n<pre>\r\nCanonicalRequest =\r\n    HTTPRequestMethod + '\\n' +\r\n    CanonicalURI + '\\n' +\r\n    CanonicalQueryString + '\\n' +\r\n    CanonicalHeaders + '\\n' +\r\n    SignedHeaders + '\\n' +\r\n    HexEncode(Hash(RequestPayload))\r\n</pre>\r\n*/\n\n\nvar canonical_request = function canonical_request(request) {\n  var url_info = parse(request.url);\n  return [request.method || '/', encodeURIComponent(url_info.pathname).replace(/%2F/gi, '/'), canonical_query(url_info.query), canonical_headers(request.headers), signed_headers(request.headers), hash(request.data)].join('\\n');\n};\n\nvar parse_service_info = function parse_service_info(request) {\n  var url_info = parse(request.url),\n      host = url_info.host;\n  var matched = host.match(/([^\\.]+)\\.(?:([^\\.]*)\\.)?amazonaws\\.com$/);\n  var parsed = (matched || []).slice(1, 3);\n\n  if (parsed[1] === 'es') {\n    // Elastic Search\n    parsed = parsed.reverse();\n  }\n\n  return {\n    service: request.service || parsed[0],\n    region: request.region || parsed[1]\n  };\n};\n\nvar credential_scope = function credential_scope(d_str, region, service) {\n  return [d_str, region, service, 'aws4_request'].join('/');\n};\n/**\r\n* @private\r\n* Create a string to sign\r\n* Refer to\r\n* {@link http://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html|Create String to Sign}\r\n*\r\n<pre>\r\nStringToSign =\r\n    Algorithm + \\n +\r\n    RequestDateTime + \\n +\r\n    CredentialScope + \\n +\r\n    HashedCanonicalRequest\r\n</pre>\r\n*/\n\n\nvar string_to_sign = function string_to_sign(algorithm, canonical_request, dt_str, scope) {\n  return [algorithm, dt_str, scope, hash(canonical_request)].join('\\n');\n};\n/**\r\n* @private\r\n* Create signing key\r\n* Refer to\r\n* {@link http://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html|Calculate Signature}\r\n*\r\n<pre>\r\nkSecret = your secret access key\r\nkDate = HMAC(\"AWS4\" + kSecret, Date)\r\nkRegion = HMAC(kDate, Region)\r\nkService = HMAC(kRegion, Service)\r\nkSigning = HMAC(kService, \"aws4_request\")\r\n</pre>\r\n*/\n\n\nvar get_signing_key = function get_signing_key(secret_key, d_str, service_info) {\n  logger.debug(service_info);\n  var k = 'AWS4' + secret_key,\n      k_date = encrypt(k, d_str),\n      k_region = encrypt(k_date, service_info.region),\n      k_service = encrypt(k_region, service_info.service),\n      k_signing = encrypt(k_service, 'aws4_request');\n  return k_signing;\n};\n\nvar get_signature = function get_signature(signing_key, str_to_sign) {\n  return toHex(encrypt(signing_key, str_to_sign));\n};\n/**\r\n * @private\r\n * Create authorization header\r\n * Refer to\r\n * {@link http://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html|Add the Signing Information}\r\n */\n\n\nvar get_authorization_header = function get_authorization_header(algorithm, access_key, scope, signed_headers, signature) {\n  return [algorithm + ' ' + 'Credential=' + access_key + '/' + scope, 'SignedHeaders=' + signed_headers, 'Signature=' + signature].join(', ');\n};\n\nvar Signer =\n/** @class */\nfunction () {\n  function Signer() {}\n  /**\r\n  * Sign a HTTP request, add 'Authorization' header to request param\r\n  * @method sign\r\n  * @memberof Signer\r\n  * @static\r\n  *\r\n  * @param {object} request - HTTP request object\r\n  <pre>\r\n  request: {\r\n      method: GET | POST | PUT ...\r\n      url: ...,\r\n      headers: {\r\n          header1: ...\r\n      },\r\n      data: data\r\n  }\r\n  </pre>\r\n  * @param {object} access_info - AWS access credential info\r\n  <pre>\r\n  access_info: {\r\n      access_key: ...,\r\n      secret_key: ...,\r\n      session_token: ...\r\n  }\r\n  </pre>\r\n  * @param {object} [service_info] - AWS service type and region, optional,\r\n  *                                  if not provided then parse out from url\r\n  <pre>\r\n  service_info: {\r\n      service: ...,\r\n      region: ...\r\n  }\r\n  </pre>\r\n  *\r\n  * @returns {object} Signed HTTP request\r\n  */\n\n\n  Signer.sign = function (request, access_info, service_info) {\n    if (service_info === void 0) {\n      service_info = null;\n    }\n\n    request.headers = request.headers || {}; // datetime string and date string\n\n    var dt = DateUtils.getDateWithClockOffset(),\n        dt_str = dt.toISOString().replace(/[:\\-]|\\.\\d{3}/g, ''),\n        d_str = dt_str.substr(0, 8);\n    var url_info = parse(request.url);\n    request.headers['host'] = url_info.host;\n    request.headers['x-amz-date'] = dt_str;\n\n    if (access_info.session_token) {\n      request.headers['X-Amz-Security-Token'] = access_info.session_token;\n    } // Task 1: Create a Canonical Request\n\n\n    var request_str = canonical_request(request);\n    logger.debug(request_str); // Task 2: Create a String to Sign\n\n    var serviceInfo = service_info || parse_service_info(request),\n        scope = credential_scope(d_str, serviceInfo.region, serviceInfo.service),\n        str_to_sign = string_to_sign(DEFAULT_ALGORITHM, request_str, dt_str, scope); // Task 3: Calculate the Signature\n\n    var signing_key = get_signing_key(access_info.secret_key, d_str, serviceInfo),\n        signature = get_signature(signing_key, str_to_sign); // Task 4: Adding the Signing information to the Request\n\n    var authorization_header = get_authorization_header(DEFAULT_ALGORITHM, access_info.access_key, scope, signed_headers(request.headers), signature);\n    request.headers['Authorization'] = authorization_header;\n    return request;\n  };\n\n  Signer.signUrl = function (urlOrRequest, accessInfo, serviceInfo, expiration) {\n    var urlToSign = typeof urlOrRequest === 'object' ? urlOrRequest.url : urlOrRequest;\n    var method = typeof urlOrRequest === 'object' ? urlOrRequest.method : 'GET';\n    var body = typeof urlOrRequest === 'object' ? urlOrRequest.body : undefined;\n    var now = DateUtils.getDateWithClockOffset().toISOString().replace(/[:\\-]|\\.\\d{3}/g, '');\n    var today = now.substr(0, 8); // Intentionally discarding search\n\n    var _a = parse(urlToSign, true, true),\n        search = _a.search,\n        parsedUrl = __rest(_a, [\"search\"]);\n\n    var host = parsedUrl.host;\n    var signedHeaders = {\n      host: host\n    };\n\n    var _b = serviceInfo || parse_service_info({\n      url: format(parsedUrl)\n    }),\n        region = _b.region,\n        service = _b.service;\n\n    var credentialScope = credential_scope(today, region, service); // IoT service does not allow the session token in the canonical request\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n\n    var sessionTokenRequired = accessInfo.session_token && service !== IOT_SERVICE_NAME;\n\n    var queryParams = __assign(__assign(__assign({\n      'X-Amz-Algorithm': DEFAULT_ALGORITHM,\n      'X-Amz-Credential': [accessInfo.access_key, credentialScope].join('/'),\n      'X-Amz-Date': now.substr(0, 16)\n    }, sessionTokenRequired ? {\n      'X-Amz-Security-Token': \"\" + accessInfo.session_token\n    } : {}), expiration ? {\n      'X-Amz-Expires': \"\" + expiration\n    } : {}), {\n      'X-Amz-SignedHeaders': Object.keys(signedHeaders).join(',')\n    });\n\n    var canonicalRequest = canonical_request({\n      method: method,\n      url: format(__assign(__assign({}, parsedUrl), {\n        query: __assign(__assign({}, parsedUrl.query), queryParams)\n      })),\n      headers: signedHeaders,\n      data: body\n    });\n    var stringToSign = string_to_sign(DEFAULT_ALGORITHM, canonicalRequest, now, credentialScope);\n    var signing_key = get_signing_key(accessInfo.secret_key, today, {\n      region: region,\n      service: service\n    });\n    var signature = get_signature(signing_key, stringToSign);\n\n    var additionalQueryParams = __assign({\n      'X-Amz-Signature': signature\n    }, accessInfo.session_token && {\n      'X-Amz-Security-Token': accessInfo.session_token\n    });\n\n    var result = format({\n      protocol: parsedUrl.protocol,\n      slashes: true,\n      hostname: parsedUrl.hostname,\n      port: parsedUrl.port,\n      pathname: parsedUrl.pathname,\n      query: __assign(__assign(__assign({}, parsedUrl.query), queryParams), additionalQueryParams)\n    });\n    return result;\n  };\n\n  return Signer;\n}();\n\nexport { Signer };\n/**\r\n * @deprecated use per-function import\r\n */\n\nexport default Signer;","map":null,"metadata":{},"sourceType":"module"}